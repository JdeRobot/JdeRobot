// **********************************************************************
//
// Copyright (c) 2003-2016 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.6.3
//
// <auto-generated>
//
// Generated from file `jcm.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __jderobot__home_fran_fqez_build_src_interfaces_cpp_jderobot_jcm_h__
#define __jderobot__home_fran_fqez_build_src_interfaces_cpp_jderobot_jcm_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <IceUtil/ScopedArray.h>
#include <IceUtil/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 306
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 > 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 3
#       error Ice patch level mismatch!
#   endif
#endif

namespace jderobot
{

struct FQExecutableName
{
    ::std::string executable;
    ::std::string host;

    bool operator==(const FQExecutableName& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(executable != __rhs.executable)
        {
            return false;
        }
        if(host != __rhs.host)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FQExecutableName& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(executable < __rhs.executable)
        {
            return true;
        }
        else if(__rhs.executable < executable)
        {
            return false;
        }
        if(host < __rhs.host)
        {
            return true;
        }
        else if(__rhs.host < host)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FQExecutableName& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FQExecutableName& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FQExecutableName& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FQExecutableName& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct FQComponentName
{
    ::std::string platform;
    ::std::string component;

    bool operator==(const FQComponentName& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(platform != __rhs.platform)
        {
            return false;
        }
        if(component != __rhs.component)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FQComponentName& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(platform < __rhs.platform)
        {
            return true;
        }
        else if(__rhs.platform < platform)
        {
            return false;
        }
        if(component < __rhs.component)
        {
            return true;
        }
        else if(__rhs.component < component)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FQComponentName& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FQComponentName& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FQComponentName& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FQComponentName& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct FQInterfaceName
{
    ::std::string platform;
    ::std::string component;
    ::std::string iface;

    bool operator==(const FQInterfaceName& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(platform != __rhs.platform)
        {
            return false;
        }
        if(component != __rhs.component)
        {
            return false;
        }
        if(iface != __rhs.iface)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FQInterfaceName& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(platform < __rhs.platform)
        {
            return true;
        }
        else if(__rhs.platform < platform)
        {
            return false;
        }
        if(component < __rhs.component)
        {
            return true;
        }
        else if(__rhs.component < component)
        {
            return false;
        }
        if(iface < __rhs.iface)
        {
            return true;
        }
        else if(__rhs.iface < iface)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FQInterfaceName& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FQInterfaceName& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FQInterfaceName& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FQInterfaceName& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct FQTopicName
{
    ::std::string platform;
    ::std::string component;
    ::std::string iface;
    ::std::string topic;

    bool operator==(const FQTopicName& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(platform != __rhs.platform)
        {
            return false;
        }
        if(component != __rhs.component)
        {
            return false;
        }
        if(iface != __rhs.iface)
        {
            return false;
        }
        if(topic != __rhs.topic)
        {
            return false;
        }
        return true;
    }

    bool operator<(const FQTopicName& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(platform < __rhs.platform)
        {
            return true;
        }
        else if(__rhs.platform < platform)
        {
            return false;
        }
        if(component < __rhs.component)
        {
            return true;
        }
        else if(__rhs.component < component)
        {
            return false;
        }
        if(iface < __rhs.iface)
        {
            return true;
        }
        else if(__rhs.iface < iface)
        {
            return false;
        }
        if(topic < __rhs.topic)
        {
            return true;
        }
        else if(__rhs.topic < topic)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const FQTopicName& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const FQTopicName& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const FQTopicName& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const FQTopicName& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct ProvidedInterface
{
    ::std::string name;
    ::std::string id;

    bool operator==(const ProvidedInterface& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ProvidedInterface& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ProvidedInterface& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const ProvidedInterface& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const ProvidedInterface& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const ProvidedInterface& __rhs) const
    {
        return !operator<(__rhs);
    }
};

struct RequiredInterface
{
    ::jderobot::FQInterfaceName name;
    ::std::string id;

    bool operator==(const RequiredInterface& __rhs) const
    {
        if(this == &__rhs)
        {
            return true;
        }
        if(name != __rhs.name)
        {
            return false;
        }
        if(id != __rhs.id)
        {
            return false;
        }
        return true;
    }

    bool operator<(const RequiredInterface& __rhs) const
    {
        if(this == &__rhs)
        {
            return false;
        }
        if(name < __rhs.name)
        {
            return true;
        }
        else if(__rhs.name < name)
        {
            return false;
        }
        if(id < __rhs.id)
        {
            return true;
        }
        else if(__rhs.id < id)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const RequiredInterface& __rhs) const
    {
        return !operator==(__rhs);
    }
    bool operator<=(const RequiredInterface& __rhs) const
    {
        return operator<(__rhs) || operator==(__rhs);
    }
    bool operator>(const RequiredInterface& __rhs) const
    {
        return !operator<(__rhs) && !operator==(__rhs);
    }
    bool operator>=(const RequiredInterface& __rhs) const
    {
        return !operator<(__rhs);
    }
};

typedef ::std::vector< ::jderobot::ProvidedInterface> ProvidesInterfaces;

typedef ::std::vector< ::jderobot::RequiredInterface> RequiresInterfaces;

struct ComponentData
{
    ::jderobot::FQComponentName name;
    ::jderobot::ProvidesInterfaces provides;
    ::jderobot::RequiresInterfaces requires;
};

}

namespace Ice
{
template<>
struct StreamableTraits< ::jderobot::FQExecutableName>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::FQExecutableName, S>
{
    static void write(S* __os, const ::jderobot::FQExecutableName& v)
    {
        __os->write(v.executable);
        __os->write(v.host);
    }
};

template<class S>
struct StreamReader< ::jderobot::FQExecutableName, S>
{
    static void read(S* __is, ::jderobot::FQExecutableName& v)
    {
        __is->read(v.executable);
        __is->read(v.host);
    }
};

template<>
struct StreamableTraits< ::jderobot::FQComponentName>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::FQComponentName, S>
{
    static void write(S* __os, const ::jderobot::FQComponentName& v)
    {
        __os->write(v.platform);
        __os->write(v.component);
    }
};

template<class S>
struct StreamReader< ::jderobot::FQComponentName, S>
{
    static void read(S* __is, ::jderobot::FQComponentName& v)
    {
        __is->read(v.platform);
        __is->read(v.component);
    }
};

template<>
struct StreamableTraits< ::jderobot::FQInterfaceName>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 3;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::FQInterfaceName, S>
{
    static void write(S* __os, const ::jderobot::FQInterfaceName& v)
    {
        __os->write(v.platform);
        __os->write(v.component);
        __os->write(v.iface);
    }
};

template<class S>
struct StreamReader< ::jderobot::FQInterfaceName, S>
{
    static void read(S* __is, ::jderobot::FQInterfaceName& v)
    {
        __is->read(v.platform);
        __is->read(v.component);
        __is->read(v.iface);
    }
};

template<>
struct StreamableTraits< ::jderobot::FQTopicName>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::FQTopicName, S>
{
    static void write(S* __os, const ::jderobot::FQTopicName& v)
    {
        __os->write(v.platform);
        __os->write(v.component);
        __os->write(v.iface);
        __os->write(v.topic);
    }
};

template<class S>
struct StreamReader< ::jderobot::FQTopicName, S>
{
    static void read(S* __is, ::jderobot::FQTopicName& v)
    {
        __is->read(v.platform);
        __is->read(v.component);
        __is->read(v.iface);
        __is->read(v.topic);
    }
};

template<>
struct StreamableTraits< ::jderobot::ProvidedInterface>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::ProvidedInterface, S>
{
    static void write(S* __os, const ::jderobot::ProvidedInterface& v)
    {
        __os->write(v.name);
        __os->write(v.id);
    }
};

template<class S>
struct StreamReader< ::jderobot::ProvidedInterface, S>
{
    static void read(S* __is, ::jderobot::ProvidedInterface& v)
    {
        __is->read(v.name);
        __is->read(v.id);
    }
};

template<>
struct StreamableTraits< ::jderobot::RequiredInterface>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::RequiredInterface, S>
{
    static void write(S* __os, const ::jderobot::RequiredInterface& v)
    {
        __os->write(v.name);
        __os->write(v.id);
    }
};

template<class S>
struct StreamReader< ::jderobot::RequiredInterface, S>
{
    static void read(S* __is, ::jderobot::RequiredInterface& v)
    {
        __is->read(v.name);
        __is->read(v.id);
    }
};

template<>
struct StreamableTraits< ::jderobot::ComponentData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 4;
    static const bool fixedLength = false;
};

template<class S>
struct StreamWriter< ::jderobot::ComponentData, S>
{
    static void write(S* __os, const ::jderobot::ComponentData& v)
    {
        __os->write(v.name);
        __os->write(v.provides);
        __os->write(v.requires);
    }
};

template<class S>
struct StreamReader< ::jderobot::ComponentData, S>
{
    static void read(S* __is, ::jderobot::ComponentData& v)
    {
        __is->read(v.name);
        __is->read(v.provides);
        __is->read(v.requires);
    }
};

}

#include <IceUtil/PopDisableWarnings.h>
#endif
