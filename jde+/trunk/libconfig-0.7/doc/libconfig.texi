\input texinfo.tex    @c -*-texinfo-*-
@c 
@c %**start of header

@c All text is ignored before the setfilename.
@setfilename libconfig.info
@settitle libconfig @value{edition}

@set edition 0.7
@set update-month November 2005
@set update-date 26 @value{update-month}

@comment %**end of header

@tex
\global\emergencystretch = .3\hsize
@end tex

@setchapternewpage odd

@titlepage

@title libconfig
@subtitle A Library For Parsing Structured Configuration Files
@subtitle Version @value{edition}
@subtitle @value{update-date}

@author Mark A.@: Lindner

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2005  Mark A Lindner

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

@end titlepage

@contents

@ifnottex
@node Top
@comment  node-name,  next,  previous,  up
@top libconfig
@end ifnottex

@menu
* Introduction::
* Configuration Files::
* The C API::
* The C++ API::
* License::
* Function Index::
* Type Index::
@end menu

@node Introduction, Configuration Files, Top, Top
@comment  node-name,  next,  previous,  up
@menu
* Why Another Configuration File Library?::
* Using the Library from a C Program::
* Using the Library from a C++ Program::
@end menu
@chapter Introduction

@i{libconfig} is a library for parsing, manipulating, and writing
structured configuration files. The library features a fully
re-entrant parser and includes bindings for both the C and C++
programming languages.

@node Why Another Configuration File Library?, Using the Library from a C Program, , Introduction
@comment  node-name,  next,  previous,  up
@section Why Another Configuration File Library?

There are several open-source configuration file libraries available
as of this writing. This library was written because each of those
libraries falls short in one or more ways. The main features of
@i{libconfig} that set it apart from the other libraries are:

@itemize @bullet

@item A fully reentrant parser. Multiple configurations can be parsed in concurrent threads at the same time.

@item Both C @i{and} C++ bindings, as well as hooks to allow for the creation of wrappers in other languages.

@item A simple, readable, structured configuration file format.

@item A low-footprint implementation (just 72K for the C library and 138K for the C++ library) that is suitable for memory-constrained systems.

@item Proper documentation.

@end itemize

@node Using the Library from a C Program, Using the Library from a C++ Program, Why Another Configuration File Library?, Introduction
@comment  node-name,  next,  previous,  up
@section Using the Library from a C Program

To use the library from C code, include the following preprocessor
directive in your source files:

@sp 1
@example
#include <libconfig.h>
@end example
@sp 1

To link with the library, specify @samp{-lconfig} as an argument to the
linker.

@node Using the Library from a C++ Program, , Using the Library from a C Program, Introduction
@comment  node-name,  next,  previous,  up
@section Using the Library from a C++ Program

To use the library from C++, include the following preprocessor
directive in your source files:

@sp 1
@example
#include <libconfig.h++>
@end example
@sp 1

The C++ API classes are defined in the namespace @samp{libconfig}, hence the
following statement may optionally be used:

@sp 1
@example
using namespace libconfig;
@end example
@sp 1

To link with the library, specify @samp{-lconfig++} as an argument to
the linker.

@node Configuration Files, The C API, Introduction, Top
@comment  node-name,  next,  previous,  up
@menu
* Groups::
* Assignments::
* Arrays::
* Integer Values::
* Floating Point Values::
* Boolean Values::
* String Values::
* Comments::
@end menu
@chapter Configuration Files

The @i{libconfig} library supports structured, hierarchical
configuration files. The configuration file format somewhat resembles C
source code.

A configuration file consists of @dfn{settings}, which include groups
and assignments. A @dfn{group} associates a collection of settings (or
other groups) with a name, while an @i{assignment} associates a single
value with a name. A @dfn{value} can have one of the four basic types
(integer, floating point number, boolean, or string), or it can be an
array of any of the aforementioned types.

Consider the following configuration file for a hypothetical GUI
application, which illustrates all of the elements of the configuration
file grammar.

@sp 1
@example
@cartouche
# Example application configuration file

version = "1.0";

application
  @{
  window
    @{
    title = "My Application";
    size @{ w = 640; h = 480; @}
    pos @{ x = 350; y = 250; @}
    @}

  splash_screen = FALSE;

  misc
    @{
    pi = 3.141592654;
    columns = [ "Last Name", "First Name", "MI" ];
    @}
  @}
@end cartouche
@end example
@sp 1

Each setting is uniquely identified within the configuration by a
@dfn{path}. The path is a dot-separated sequence of group names
beginning at a top-level group and ending at the setting itself. For
example, in our hypothetical configuration file, the path to the
@code{x} setting is @code{application.window.pos.x}, while the path to
the @code{version} setting is simply @code{version}.

The datatype of a value is determined from the format of the value
itself. If the value is enclosed in double quotes, it is treated as a
string. If it looks like an integer or floating point number, it is
treated as such. If it is either the value @code{TRUE} or @code{FALSE},
it is treated as a boolean. And if it consists of a comma-separated list
of values enclosed in square brackets, it is treated as an array. Any
value which does not meet any of the above conditions is considered
invalid and results in a parse error.

All names are case-sensitive. They may consist only of alphanumeric
characters, dashes, and underscores, and must begin with a letter. No
other characters are allowed.

In C and C++, integer, floating point, and string values are mapped to
the types @code{long}, @code{double}, and @code{const char *},
respectively. The boolean type is mapped to @code{int} in C and
@code{bool} in C++.

The following sections describe the elements of the configuration file
grammar in additional detail.

@node Groups, Assignments, , Configuration Files
@comment  node-name,  next,  previous,  up
@section Groups

A group definition has the form:

@i{name}
@b{@{}
   @i{settings ...}
@b{@}}

An optional semicolon may appear after the closing brace.

Groups can contain any number of settings, and can be nested to
arbitrary depth.

@node Assignments, Arrays, Groups, Configuration Files
@comment  node-name,  next,  previous,  up
@section Assignments

An assignment has the form:

@i{name} @b{=} @i{value} @b{;}

The trailing semicolon is required.

The value may be a simple value or an array.

@node Arrays, Integer Values, Assignments, Configuration Files
@comment  node-name,  next,  previous,  up
@section Arrays

An array has the form:

@b{[} @i{value}@b{,} @i{value ...} @b{]}

An array may have zero or more elements, but the elements must all be of
the same type.

@node Integer Values, Floating Point Values, Arrays, Configuration Files
@comment  node-name,  next,  previous,  up
@section Integer Values

Integers must consist only of digits, and may have an optional leading sign
character (@samp{+} or @samp{-}).

@node Floating Point Values, Boolean Values, Integer Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section Floating Point Values

Floating point values must consist only of digits, one decimal point, an
optional leading sign character (@samp{+} or @samp{-}), and an optional exponent.

@node Boolean Values, String Values, Floating Point Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section Boolean Values

Boolean values may have one of the following two values: @code{TRUE},
@code{FALSE}.

@node String Values, Comments, Boolean Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section String Values

String values consist of arbitrary text delimited by double
quotes. Literal double quotes can be escaped by preceding them with a
backslash: @samp{\"}. The escape sequences @samp{\\}, @samp{\f},
@samp{\n}, @samp{\r}, and @samp{\t} are also recognized, and have the
usual meaning. No other escape sequences are currently supported.

@node Comments, , String Values, Configuration Files
@comment  node-name,  next,  previous,  up
@section Comments

Three types of comments are allowed within a configuration:

@itemize @bullet

@item Script-style comments. All text beginning with a @samp{#} character
to the end of the line is ignored.

@item C-style comments. All text, including line breaks, between a starting
@samp{/*} sequence and an ending @samp{*/} sequence is ignored.

@item C++-style comments. All text beginning with a @samp{//} sequence to the
end of the line is ignored.

@end itemize

As expected, comment delimiters appearing within quoted strings are
treated as literal text.

Comments are ignored when the configuration is read in, so they are
not treated as part of the configuration. Therefore if the
configuration is written back out to a stream, any comments that were
present in the original configuration will be lost.

@node The C API, The C++ API, Configuration Files, Top
@comment  node-name,  next,  previous,  up
@chapter The C API

@tindex config_t
@tindex config_setting_t
This chapter describes the C library API. The type @i{config_t}
represents a configuration, and the type @i{config_setting_t} represents
a configuration setting.

@deftypefun void config_init (@w{config_t *@var{config}})
@deftypefunx void config_destroy (@w{config_t *@var{config}})

These functions initialize and destroy the configuration object @var{config}. 

@code{config_init()} initializes @var{config} as a new, empty
configuration.

@code{config_destroy()} destroys the configuration @var{config},
deallocating all memory associated with the configuration, but not
including the @i{config_t} structure itself.

@end deftypefun

@deftypefun int config_read (@w{config_t *@var{config}}, @w{FILE *@var{stream}})

This function reads and parses a configuration from the given
@var{stream} into the configuration object @var{config}. It returns
@code{1} on success, or @code{0} on failure; the
@code{config_error_text()} and @code{config_error_line()}
functions, described below, can be used to obtain information about the
error.

@end deftypefun

@deftypefun int config_load_file (@w{config_t *@var{config}}, @w{const char *@var{fname}})

This function reads and parses a configuration from the file named
@var{fname} into the configuration object @var{config}. It returns
@code{1} on success, or @code{0} on failure; the
@code{config_error_text()} and @code{config_error_line()} functions,
described below, can be used to obtain information about the error.

@end deftypefun

@deftypefun void config_write (@w{const config_t *@var{config}}, @w{FILE *@var{stream}})

This function writes the configuration @var{config} to the given
@var{stream}.

@end deftypefun

@deftypefun int config_save_file (@w{config_t *@var{config}}, @w{const char *@var{fname}})

This function writes the configuration @var{config} to the file named
@var{fname}. It returns @code{1} on success, or @code{0} on failure;
the @code{config_error_text()} and @code{config_error_line()}
functions, described below, can be used to obtain information about
the error.

@end deftypefun

@deftypefun {const char *} config_error_text (@w{const config_t *@var{config}})
@deftypefunx int config_error_line (@w{const config_t *@var{config}})

These functions, which are implemented as macros, return the text and
line number of the parse error, if one occurred during a call to
@code{config_read()}.

@end deftypefun

@deftypefun long config_lookup_int (@w{const config_t *@var{config}}, @w{const char *@var{path}})
@deftypefunx double config_lookup_float (@w{const config_t *@var{config}}, @w{const char *@var{path}})
@deftypefunx int config_lookup_bool (@w{const config_t *@var{config}}, @w{const char *@var{path}})
@deftypefunx {const char *} config_lookup_string (@w{const config_t *@var{config}}, @w{const char *@var{path}})

These functions locate the setting in the configuration @var{config}
specified by the path @var{path}. They return the value of the setting
on success, or a 0 or @code{NULL} value if the setting was not found or
if the type of the value did not match the type requested.

@end deftypefun

@deftypefun {const config_setting_t *} config_lookup (@w{const config_t *@var{config}}, @w{const char *@var{path}})

This function locates the setting in the configuration @var{config}
specified by the path @var{path}. It returns a pointer to the
@code{config_setting_t} structure on success, or @code{NULL} if the
setting was not found.

@end deftypefun

@deftypefun long config_setting_get_int (@w{const config_setting_t *@var{setting}})
@deftypefunx double config_setting_get_float (@w{const config_setting_t *@var{setting}})
@deftypefunx int config_setting_get_bool (@w{const config_setting_t *@var{setting}})
@deftypefunx {const char *} config_setting_get_string (@w{const config_setting_t *@var{setting}})

These functions return the value of the given @var{setting}. If the
type of the setting does not match the type requested, a 0 or
@code{NULL} value is returned.

@end deftypefun

@deftypefun int config_setting_set_int (@w{config_setting_t *@var{setting}}, @w{long @var{value}})
@deftypefunx int config_setting_set_float (@w{config_setting_t *@var{setting}}, @w{double @var{value}})
@deftypefunx int config_setting_set_bool (@w{config_setting_t *@var{setting}}, @w{int @var{value}})
@deftypefunx int config_setting_set_string (@w{config_setting_t *@var{setting}}, @w{const char *@var{value}})

These functions set the value of the given @var{setting} to
@var{value}. On success, they return 1. If the setting does not match
the type of the value, they return 0.

@end deftypefun

@deftypefun {config_setting_t *} config_setting_get_member (@w{const config_setting_t *@var{setting}}, @w{const char *@var{name}})

This function fetches the child setting named @var{name} from the group
@var{setting}. It returns the requested setting on success, or
@code{NULL} if the setting was not found or if @var{setting} is not a
group.

@end deftypefun

@deftypefun {config_setting_t *} config_setting_get_elem (@w{const config_setting_t *@var{setting}}, @w{int @var{index}})

This function fetches the element at the given @var{index} in the array
@var{setting}. It returns the requested setting on success, or
@code{NULL} if @var{index} is out of range or if @var{setting} is not an
array.

@end deftypefun

@deftypefun long config_setting_get_int_elem (@w{const config_setting_t *@var{array}}, @w{int @var{index}})
@deftypefunx double config_setting_get_float_elem (@w{const config_setting_t *@var{array}}, @w{int @var{index}})
@deftypefunx int config_setting_get_bool_elem (@w{const config_setting_t *@var{array}}, @w{int @var{index}})
@deftypefunx {const char *} config_setting_get_string_elem (@w{const config_setting_t *@var{array}}, @w{int @var{index}})

These functions fetch the value at the specified @var{index} in the
setting @var{array}. If the setting @var{array} is not an array, or if
the type of the element does not match the type requested, or if @var{index} is out of range, a 0 or @code{NULL} value is returned.

@end deftypefun

@deftypefun int config_setting_set_int_elem (@w{config_setting_t *@var{array}}, @w{int @var{index}}, @w{long @var{value}})
@deftypefunx int config_setting_set_float_elem (@w{config_setting_t *@var{array}}, @w{int @var{index}}, @w{double @var{value}})
@deftypefunx int config_setting_set_bool_elem (@w{config_setting_t *@var{array}}, @w{int @var{index}}, @w{int @var{value}})
@deftypefunx int config_setting_set_string_elem (@w{config_setting_t *@var{array}}, @w{int @var{index}}, @w{const char *@var{value}})

These functions set the value at the specified @var{index} in the
setting @var{array} to @var{value}. On success, they return 1. If the
type of the array does not match the type of the value, or if
@var{index} is out of range, they return 0.

@end deftypefun

@deftypefun {config_setting_t *} config_setting_add (@w{config_setting_t *@var{parent}}, @w{const char *@var{name}}, @w{int @var{type}})

This function adds a new child setting or a new array element to the
setting @var{parent}, which must be a group or array. If @var{parent}
is an array, the @var{name} parameter is ignored and may be
@code{NULL}.

The function returns the new setting on success, or
@code{NULL} if @var{parent} is not a group, if there is already a
child setting of @var{parent} named @var{name}, or if @var{type} is
invalid.

@end deftypefun

@deftypefun int config_setting_remove (@w{config_setting_t *@var{parent}}, @w{const char *@var{name}})

This function removes the setting named @var{name} from the parent
setting @var{parent}. Any child settings of the setting are
recursively destroyed as well.

The function returns 1 on success. If @var{parent} is not a group, or
if it has no setting with the given name, it returns 0.

@end deftypefun

@deftypefun {config_setting_t *} config_root_setting (@w{const config_t *@var{config}})

This function returns the root setting for the configuration
@var{config}. The root setting is an unnamed group.

@end deftypefun

@deftypefun {const char *} config_setting_name (@w{const config_setting_t *@var{setting}})

This function returns the name of the given @var{setting}.

@end deftypefun

@deftypefun int config_setting_length (@w{const config_setting_t *@var{setting}})

If @var{setting} is a group, this function returns the number of members
in the group. If it is an array, it returns the number of elements in
the array. Otherwise, it returns 0.

@end deftypefun

@deftypefun int config_setting_type (@w{const config_setting_t *@var{setting}})

This function returns the type of the given @var{setting}. The return
value is one of the constants @code{CONFIG_TYPE_GROUP},
@code{CONFIG_TYPE_INT}, @code{CONFIG_TYPE_FLOAT},
@code{CONFIG_TYPE_STRING}, @code{CONFIG_TYPE_BOOL}, or
@code{CONFIG_TYPE_ARRAY}.

@end deftypefun

@deftypefun void config_setting_set_hook (@w{const config_setting_t *@var{setting}}, @w{void *@var{hook}})
@deftypefunx {void *} config_setting_get_hook (@w{const config_setting_t *@var{setting}})

These functions make it possible to attach arbitrary data to each
setting structure. The destructor function, if one has been supplied via
a call to @code{config_set_destructor()}, will be called by the library
to dispose of this data when the setting itself is deallocated.

@end deftypefun

@deftypefun void config_set_destructor (@w{config_t *@var{config}}, @w{void (*@var{destructor})(void *)})

This function assigns the destructor function @var{destructor} for the
configuration @var{config}. This function accepts a single @code{void *}
argument and has no return value. See @code{config_setting_set_hook()} above for more information.

@end deftypefun

@node The C++ API, License, The C API, Top
@comment  node-name,  next,  previous,  up
@chapter The C++ API

@tindex Config
@tindex Setting
This chapter describes the C++ library API. The class @i{Config}
represents a configuration, and the class @i{Setting} represents a
configuraiton setting.

@tindex ConfigException
The library defines a group of exceptions, all of which extend the
common base exception @i{ConfigException}.

@tindex SettingTypeException
A @i{SettingTypeException} is thrown when the type of a setting's
value does not match the type requested.

@tindex SettingNotFoundException
A @i{SettingNotFoundException} is thrown when a setting is not found.

@tindex SettingExistsException
A @i{SettingExistsException} is thrown when an attempt is made to add
a new setting with a non-unique name.

@tindex ParseException
A @i{ParseException} is thrown when a parse error occurs while
reading a configuration from a stream. The following methods are
available to obtain the error details:

@tindex FileIOException
A @i{FileIOException} is thrown when an I/O error occurs while
reading/writing a configuration form/to a file.

@deftypemethod ParseException {const char *} getError ()
@deftypemethodx ParseException int getLine ()

These methods return the text and line number of the parse error.

@end deftypemethod

The remainder of this chapter describes the member functions for
manipulating configurations and configuration settings.

@deftypemethod Config {} Config ()
@deftypemethodx Config {} ~Config ()

These methods create and destroy @i{Config} objects. 

@end deftypemethod

@deftypemethod Config void read (@w{FILE *@var{stream}})
@deftypemethodx Config void write (@w{FILE *@var{stream}})

The @code{read()} method reads and parses a configuration from the given
@var{stream}. A @i{ParseException} is thrown if a parse error occurs.

The @code{write()} method writes the configuration to the given @var{stream}.

@end deftypemethod

@deftypemethod Config void loadFile (@w{const char *@var{fname}})
@deftypemethodx Config void saveFile (@w{const char *@var{fname}})

The @code{loadFile()} method reads and parses a configuration from the file
named @var{fname}. A @i{ParseException} is thrown if a parse error occurs. A
@i{FileIOException} is thrown if the file cannot be read.

The @code{saveFile()} method writes the configuration to the file
named @var{fname}. A @i{FileIOException} is thrown if the file cannot
be written.

@end deftypemethod

@deftypemethod Config {Setting &} lookup (@w{const std::string & @var{path}})
@deftypemethodx Config {Setting &} lookup (@w{const char * @var{path}})

These methods locate the setting specified by the path @var{path}. If
the requested setting is not found, a @i{SettingNotFoundException} is
thrown.

A @code{Setting} object may be assigned to a variable of type @i{bool}
if it is of type @code{TypeBoolean}, @i{int} or @i{long} if it is of
type @code{TypeInt}, @i{float} or @i{double} if it is of type
@code{TypeFloat}, or @w{@i{const char *}} or @i{std::string} if it is
of type @code{TypeString}.

The following example demonstrates this usage:

@cartouche
@example
long width = config.lookup("application.window.size.w");

bool splashScreen = config.lookup("application.splash_screen");
@end example
@end cartouche

If the assignment is invalid due to a type mismatch, a
@i{SettingTypeException} is thrown.

A @i{Setting} object may also be subscripted with an integer index if it
is an array, or with either a string index or an integer index if it is
a group. For example, the following expression would return the string
@samp{Last Name} when applied to the example configuration in
@ref{Configuration Files}.

@sp 1
@cartouche
@example
const Setting& setting = config.lookup("application.misc");
const char *s = setting["columns"][0];
@end example
@end cartouche

Iterating over a group's child settings with an integer index will
return the settings in the same order that they appear in the
configuration.

@end deftypemethod

@deftypemethod Config {Setting &} getRoot ()

This function returns the root setting for the configuration. The root
setting is an unnamed group.

@end deftypemethod

@deftypemethod Setting {Setting &} add (@w{const std::string & @var{name}}, @w{SettingType @var{type}})
@deftypemethodx Setting {Setting &} add (@w{const char *@var{name}}, @w{SettingType @var{type}})

These methods add a new child setting with the given @var{name} and
@var{type} to the setting, returning a reference to the new
setting. If the setting already has a child setting with the given
name, a @code{SettingExistsException} is thrown.

Once a setting has been created, neither its name nor type can be
changed.

@end deftypemethod

@deftypemethod Setting {Setting &} add (@w{SettingType @var{type}})

This method adds a new, unnamed child setting to the setting, which
must be of type @code{TypeArray}. If the array currently has zero
elements, the @var{type} parameter (which must be @code{TypeInt},
@code{TypeFloat}, @code{TypeBool}, or @code{TypeString}) determines
the type for the array, otherwise it must match the type of the
existing elements in the array.

The method returns the new setting on success. The setting will have a
default value of 0, 0.0, @code{false}, or @code{NULL}, depending on
the type.

The method throws a @code{SettingTypeException} if the setting is not
an array, or if @var{type} is invalid.

@end deftypemethod

@deftypemethod Setting void remove (@w{const std::string & @var{name}})
@deftypemethodx Setting void remove (@w{const char * @var{name}})

These methods remove the child setting with the given @var{name} from
the setting, which must be a group. Any child settings of the setting
are recursively destroyed as well.

If the setting is not a group, a @code{SettingTypeException} is
thrown.  If the setting does not have a child setting with the given
name, a @code{SettingNotFoundException} is thrown.

@end deftypemethod

@deftypemethod Setting {const char *} getName ()

This method returns the name of the setting.

@end deftypemethod

@deftypemethod Setting SettingType getType ()

@tindex SettingType
This method returns the type of the setting. The @code{SettingType}
enumeration consists of the following constants: @code{TypeNone},
@code{TypeGroup}, @code{TypeInt}, @code{TypeFloat}, @code{TypeString},
@code{TypeBoolean}, @code{TypeArray}.

@end deftypemethod

@deftypemethod Setting int getLength ()

If the setting is a group, this function returns the number of members
in the group. If it is an array, it returns the number of elements in
the array. Otherwise, it returns 0.

@end deftypemethod

@node License, Function Index, The C++ API, Top
@comment  node-name,  next,  previous,  up
@appendix License

@include LGPL.texi

@node Function Index, Type Index, License, Top
@comment  node-name,  next,  previous,  up
@unnumbered Function Index

@printindex fn

@node Type Index, , Function Index, Top
@unnumbered Type Index

@printindex tp

@bye
