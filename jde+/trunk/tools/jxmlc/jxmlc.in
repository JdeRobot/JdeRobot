#!/usr/bin/python
#-*- coding: Latin-1 -*-

import sys
import os
import optparse
from xml.dom.ext.reader import Sax2

jxmlcdatadir = "@jxmlcdatadir@"
template_dir = jxmlcdatadir
iface_tpl_header = "iface_tpl.h"
iface_tpl_defs = "iface_tpl.cpp"
schema_tpl_header = "schema_tpl.h"
schema_tpl_defs = "schema_tpl.cpp"

def normalize_whitespace(text):
    "Remove redundant whitespace from a string"
    return ' '.join(text.split())

def isvalidId(id):
    "Check if id is a valid C++ identificator"
    if len(id) > 0:
        first = id[0]
        return (first == "_" or str.isalpha(first))
    return False

def sprint_file(path):
    "Return a string with file path content"
    f = open(path,'r')

    s = ""
    l = f.readline()
    while l != "":
        s += l
        l = f.readline()

    f.close()
    return s

def replace_tag(str,tag,new):
    "Replaces tags"
    import string

    return string.replace(str,"<--!%s-->" % tag,new)

def csv_list(content,literal = False):
    "Returns a coma separated list of content."
    if literal:
        c = '"'
    else:
        c = ''
    nelem = len(content)
    list_str = ''
    for i in content:
        list_str += c + ('%s' % i) + c
        nelem -= 1
        if nelem > 0:
            list_str += ','
    
    return list_str

def bak_file(file_name):
    "If exists file name backup it"
    if os.path.exists(file_name):
        os.rename(file_name,"%s.bak" % file_name)

def gen_iface_header(tpl_file_name,prefix,i_def): #iface_name,iface_type):
    "Generate iface C++ header file(.h)"
    #Read template
    tpl = sprint_file(tpl_file_name)
    #Replace tags
    iface_header = replace_tag(tpl,"IFACE_NAME",i_def['name'])
    iface_header = replace_tag(iface_header,"IFACE_TYPE",i_def['type'])
    #Header file generation
    bak_file('%s/%s.h' % (prefix,i_def['name']))
    h_file = open('%s/%s.h' % (prefix,i_def['name']),"w")
    h_file.write("/*%s interface header generated by %s*/\n" %
                 (i_def['name'],os.path.basename(sys.argv[0])))
    h_file.write("/*DO NOT EDIT, THIS FILE MAY BE OVERWRITTEN*/\n")
    h_file.write("#ifndef %s_H\n" % i_def['name'].upper())
    h_file.write("#define %s_H\n" % i_def['name'].upper())
    h_file.write(iface_header);
    h_file.write("#endif /*%s_H*/\n" % i_def['name'].upper())
    h_file.close()
    
def gen_iface_definition(tpl_file_name,prefix,i_def): #iface_name,iface_type,perceptions,modulations):
    "Generate iface C++ definition file(.cpp)"
    #Read template
    tpl = sprint_file(tpl_file_name)
    #Replace tags
    iface_def = replace_tag(tpl,"IFACE_NAME",i_def['name'])
    iface_def = replace_tag(iface_def,"PERCEPTIONS",csv_list(i_def['perceptions'],True))
    iface_def = replace_tag(iface_def,"MODULATIONS",csv_list(i_def['modulations'],True))
    #Definitions file generation
    bak_file('%s/%s.cpp' % (prefix,i_def['name']))
    cpp_file = open('%s/%s.cpp' % (prefix,i_def['name']),"w")
    cpp_file.write("/*%s interface def generated by %s*/\n" %
                   (i_def['name'],os.path.basename(sys.argv[0])))
    cpp_file.write("/*DO NOT EDIT, THIS FILE MAY BE OVERWRITTEN*/\n")
    #include .h
    cpp_file.write('#include "%s.h"\n' % i_def['name'])
    cpp_file.write(iface_def)
    cpp_file.close()

def gen_schema_header(tpl_file_name,prefix,s_def): #schema_name,schema_interface,schema_branch,children):
    "Generate schema C++ header file(.h)"
    
    #Read template
    tpl = sprint_file(tpl_file_name)
    #Replace tags
    schema_header = replace_tag(tpl,"SCHEMA_NAME",s_def['name'])
    schema_header = replace_tag(schema_header,"SCHEMA_INTERFACE",s_def['interface']['name'])
    includes = []
    includes.append(s_def['interface']['library'])
    schema_header = replace_tag(schema_header,"SCHEMA_BRANCH",s_def['branch'])
    #children interfaces & branches
    children_init = []
    children_branch = ""
    for c in s_def['children']:
        children_init.append('new %s("%s")' % (c['interface']['name'],c['nick']))
        includes.append(c['interface']['library'])
        children_branch += 'cb["%s"];\n' % c['nick']
        for b in c['branch']:
            children_branch += 'cb["%s"].push_back("%s");\n' % (c['nick'],b)
    schema_header = replace_tag(schema_header,"CHILDREN_INTERFACES",csv_list(children_init))
    schema_header = replace_tag(schema_header,"CHILDREN_BRANCH_PREF_PUSH",children_branch)
    schema_header = replace_tag(schema_header,"USER_HANDLERS","")
    schema_header = replace_tag(schema_header,"USER_PRIVATE_MEMBERS","")
    #Header file generation
    bak_file('%s/%s.h' % (prefix,s_def['name']))
    h_file = open('%s/%s.h' % (prefix,s_def['name']),"w")
    h_file.write("/*%s schema header generated by %s*/\n" %
                 (s_def['name'],os.path.basename(sys.argv[0])))
    h_file.write("/*DO NOT EDIT, THIS FILE MAY BE OVERWRITTEN*/\n")
    h_file.write("#ifndef %s_H\n" % s_def['name'].upper())
    h_file.write("#define %s_H\n" % s_def['name'].upper())
    for i in set(includes): #remove dup entries
        h_file.write("#include <%s.h>\n" % i)
    h_file.write(schema_header)
    h_file.write("#endif /*%s_H*/\n" % s_def['name'].upper())
    h_file.close()

def gen_schema_definition(tpl_file_name,prefix,s_def):
    "Generate schema C++ definition file(.cpp)"
    
    #Read template
    tpl = sprint_file(tpl_file_name)
    #Replace tagssc
    schema_def = replace_tag(tpl,"SCHEMA_NAME",s_def['name'])
    schema_def = replace_tag(schema_def,"USER_HANDLERS","")
    schema_def = replace_tag(schema_def,"USER_PRIVATE_MEMBERS","")
    #Definitions file generation
    bak_file('%s/%s.cpp' % (prefix,s_def['name']))
    cpp_file = open('%s/%s.cpp' % (prefix,s_def['name']),"w")
    cpp_file.write("/*%s interface def generated by %s*/\n" %
                   (s_def['name'],os.path.basename(sys.argv[0])))
    cpp_file.write("/*YOU CAN EDIT THIS FILE. ONLY OVERWRITTEN WITH -s OPTION*/\n")
    #include .h
    cpp_file.write('#include "%s.h"\n' % s_def['name'])
    cpp_file.write(schema_def)
    cpp_file.close()

def gen_library_header(prefix,library,interfaces):
    #Header file generation
    bak_file('%s/%s.h' % (prefix,library))
    h_file = open('%s/%s.h' % (prefix,library),'w')
    h_file.write('/*%s library header generated by %s*/\n' %
                 (library,os.path.basename(sys.argv[0])))
    h_file.write("/*DO NOT EDIT, THIS FILE MAY BE OVERWRITTEN*/\n")
    h_file.write("#ifndef %s_H\n" % library.upper())
    h_file.write("#define %s_H\n" % library.upper())

    extheaders = set()
    for i in interfaces:
        h_file.write('#include <%s.h>\n' % i['name'])
        extheaders.update(i['extheaders'])

    for h in extheaders:
        h_file.write('#include <%s>\n' % h)

    h_file.write('#endif /*%s_H*/\n' % library.upper())
    h_file.close()

def gen_makefile_am(prefix,xml_filepath,i_defs,s_defs,libs):
    xml_filename = os.path.basename(xml_filepath)
    bak_file('%s/Makefile.am' % prefix)
    m_file = open('%s/Makefile.am' % prefix,'w')
    m_file.write('# Makefile.am generated by %s\n' %
                 os.path.basename(sys.argv[0]))
    m_file.write('# YOU CAN EDIT THIS FILE. ONLY OVERWRITTEN WITH -i OPTION\n')
    m_file.write('EXTRA_DIST = %s\n' % xml_filename)
    generated_files = []
    for i in i_defs:
        generated_files.append('%s.h' % i['name'])
        generated_files.append('%s.cpp' % i['name'])

    for s in s_defs:
        generated_files.append('%s.h' % s['name'])

    for l in libs.iterkeys():
        generated_files.append('%s.h' % l)

    m_file.write('AUTO_GEN = ')
    for g in generated_files:
        m_file.write('%s ' % g)
    m_file.write('\n')

    m_file.write('''
JXMLC = @JXMLC@

Makefile.am: %s
\t$(JXMLC) -m $^

$(AUTO_GEN): %s
\t$(JXMLC) $^

CLEANFILES = $(AUTO_GEN)

#Libs to build
libdir = $(prefix)
''' % (xml_filename,xml_filename))

    #define all libs to be built
    m_file.write('lib_LTLIBRARIES = ')
    for l in libs.iterkeys():
        m_file.write('lib' + l + '.la ')
    for s in s_defs:
        m_file.write(s['name']+'.la ')
    m_file.write('\n')

    #interface libs
    #headers are used as source becouse they not need to be installed
    sources = ''
    extsources = ''
    for l,ifaces in libs.iteritems():
        sources = 'nodist_lib%s_la_SOURCES = %s.h ' % (l,l) #autgenerated sources -> nodist
        extsources = 'lib%s_la_SOURCES = ' % l
        
        exths = set()
        extss = set()
        for i in ifaces:
            sources += '%s.h %s.cpp ' % (i['name'],i['name'])
            exths.update(i['extheaders'])
            extss.update(i['extsources'])

        for h in exths:
            extsources += h + ' '
        for s in extss:
            extsources += s + ' '
        
    m_file.write(sources + '\n')
    m_file.write(extsources + '\n\n')
    
    #schema modules
    for s in s_defs:
        m_file.write('%s_la_SOURCES = %s.cpp ' % (s['name'],s['name']))
        extcode = set(s['extheaders']+s['extsources'])
        for c in extcode:
             m_file.write(c + ' ')
        m_file.write('\n')

        m_file.write('%s_la_LIBADD = ' % s['name'])
        #main interface lib
        s_libs = set()
        s_libs.add(s['interface']['library'])
        #children libraries
        for c in s['children']:
            s_libs.add(c['interface']['library'])
        for l in s_libs:
            m_file.write('lib' + l + '.la ')
        if len(s['extlibs']) > 0:
            extlibs = set(s['extlibs'])
            for l in extlibs:
                m_file.write(l + ' ')
        m_file.write('\n')
        m_file.write('%s_la_LDFLAGS = -module\n' % s['name'])
        m_file.write('\n')
    m_file.close()

def get_interface_def(interface_def_node):
    if interface_def_node.tagName.encode() != 'interfaceDef':
        raise Exception('Unknown node: %s' % interface_def_node.tagName)

    i_def = {}
    i_def['name'] = interface_def_node.getAttribute('name').encode()
    if interface_def_node.hasAttribute('type'):
        i_def['type'] = interface_def_node.getAttribute('type').encode().upper()
    else:
        i_def['type'] = 'PSCHEMA'

    i_def['perceptions'] = []
    perceptions = interface_def_node.getElementsByTagName('perception')
    for p in perceptions:
        i_def['perceptions'].append(p.firstChild.nodeValue.encode())

    i_def['modulations'] = []
    modulations = interface_def_node.getElementsByTagName('modulation')
    for m in modulations:
        i_def['modulations'].append(m.firstChild.nodeValue.encode())

    library = interface_def_node.getElementsByTagName('library')
    if len(library) > 0:
        i_def['library'] = library[0].firstChild.nodeValue.encode()
    else:
        #FIXME: cuando se valide el documento esto no deberia pasar
        raise Exception('Interface library not expecified')

    extsources = interface_def_node.getElementsByTagName('extsource')
    i_def['extsources'] = []
    for s in extsources:
        i_def['extsources'].append(s.firstChild.nodeValue.encode())

    extheaders = interface_def_node.getElementsByTagName('extheader')
    i_def['extheaders'] = []
    for h in extheaders:
        i_def['extheaders'].append(h.firstChild.nodeValue.encode())

    return i_def

def get_interface(interface_node):
    if interface_node.tagName.encode() != 'interface':
        raise Exception('Unknown node: %s' % interface_node.tagName)

    interface = {}
    interface['name'] = interface_node.getAttribute('name').encode()
    libraries = interface_node.getElementsByTagName('library')
    if len(libraries) > 0:
        interface['library'] = libraries[0].firstChild.nodeValue.encode()
    else:
        #FIXME: cuando se valide el documento esto no deberia pasar
        raise Exception('Interface library not expecified')
    
    return interface

def get_child(child_node):
    if child_node.tagName.encode() != 'child':
        raise Exception('Unknown node: %s' % child_node.tagName)

    child = {}
    interfaces = child_node.getElementsByTagName('interface')
    if len(interfaces) > 0:
        child['interface'] = get_interface(interfaces[0])
    else:
        #FIXME: cuando se valide el documento esto no deberia pasar
        raise Exception('Child interface not expecified')

    child['branch'] = []
    branches = child_node.getElementsByTagName('branch')
    for b in branches:
        child['branch'].append(b.firstChild.nodeValue.encode())
    if child_node.hasAttribute('nick'):
        child['nick'] = child_node.getAttribute('nick').encode()
    else:
        child['nick'] = child['interface']['name']

    return child

def get_schema_def(schema_def_node):
    if schema_def_node.tagName.encode() != 'schemaDef':
        raise Exception('Unknown node: %s' % schema_def_node.tagName)

    s_def = {}
    s_def['name'] = schema_def_node.getAttribute('name').encode()
    
    interfaces = schema_def_node.getElementsByTagName('interface')
    if len(interfaces) > 0:
        s_def['interface'] = get_interface(interfaces[0])
    else:
        #FIXME: cuando se valide el documento esto no deberia pasar
        raise Exception('Schema interface not expecified')

    s_def['children'] = []
    children = schema_def_node.getElementsByTagName('child')
    for c in children:
        s_def['children'].append(get_child(c))

    branch = schema_def_node.getElementsByTagName('branch')
    if len(branch) > 0:
        s_def['branch'] = branch[0].firstChild.nodeValue.encode()
    else:
        s_def['branch'] = 'default'

    extsources = schema_def_node.getElementsByTagName('extsource')
    s_def['extsources'] = []
    for s in extsources:
        s_def['extsources'].append(s.firstChild.nodeValue.encode())

    extheaders = schema_def_node.getElementsByTagName('extheader')
    s_def['extheaders'] = []
    for h in extheaders:
        s_def['extheaders'].append(h.firstChild.nodeValue.encode())

    extlibs = schema_def_node.getElementsByTagName('extlib')
    s_def['extlibs'] = []
    for l in extlibs:
        s_def['extlibs'].append(l.firstChild.nodeValue.encode())

    return s_def

def main():
    op = optparse.OptionParser('usage: %prog [-imspt] arg')
    op.add_option("-i","--init-project", action="store_true",
                  dest="init_project",help="Generate all files, defs and Makefile.am")
    op.add_option("-s","--generate-schema-defs", action="store_true",
                  dest="schemas_defs",help="Generate schema definitions")
    op.add_option("-m","--generate-makefile", action="store_true",
                  dest="makefile",help="Generate Makefile.am")
    op.add_option("-p","--dest-prefix",dest="prefix",
                  help="Output prefix path",default=".")
    op.add_option("-t","--template-dir",dest="template_dir",
                  help="Template directory",default=template_dir)

    (options, args) = op.parse_args()
    
    if len(args) != 1:
        op.error("incorrect number of arguments")

    #check if prefix exists. If it doesn't exists create dir
    if not os.path.exists(options.prefix):
        os.mkdir(options.prefix)
    #check if prefix is a dir
    if not os.path.isdir(options.prefix):
        sys.stderr.write("'%s' is'nt a directory. Can't write output in it\n" % options.prefix)
        sys.exit(3)


    reader = Sax2.Reader()
    xml_filename = args[0]
    xml_file = open(xml_filename,'r')
    doc = reader.fromStream(xml_file)

    interface_defs_parsed = []
    schema_defs_parsed = []

    interface_defs = doc.getElementsByTagName('interfaceDef')
    for i in interface_defs:
        i_def = get_interface_def(i)
        print i_def
        gen_iface_header("%s/%s" % (options.template_dir,iface_tpl_header),
                         options.prefix,i_def)
        gen_iface_definition("%s/%s" % (options.template_dir,iface_tpl_defs),
                             options.prefix,i_def)
                             #i["name"],i["type"],i["perceptions"],i["modulations"])
        interface_defs_parsed.append(i_def)

    libraries = {}
    for i in interface_defs_parsed:
        if not libraries.has_key(i['library']):
            libraries[i['library']] = []
        libraries[i['library']].append(i)

    for l,i in libraries.iteritems():
        gen_library_header(options.prefix,l,i)

    schema_defs = doc.getElementsByTagName('schemaDef')
    for s in schema_defs:
        s_def = get_schema_def(s)
        print s_def
        gen_schema_header("%s/%s" % (options.template_dir,schema_tpl_header),
                          options.prefix,s_def)
                          #s["name"],s["interface"],s["branch"],s["children"])
        if options.schemas_defs or options.init_project:
            gen_schema_definition("%s/%s" % (options.template_dir,schema_tpl_defs),
                                  options.prefix,s_def)
                                  #s["name"])
        schema_defs_parsed.append(s_def)

    if options.makefile or options.init_project:
        gen_makefile_am(options.prefix,xml_filename,interface_defs_parsed,
                        schema_defs_parsed,libraries)
    
    sys.exit(0)


if __name__ == '__main__':
    main()
